<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System with Three.js</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #f5f5f5;
            background-color: #04040c;
        }

        canvas {
            display: block;
        }

        #asteroid-panel {
            position: fixed;
            top: 1rem;
            left: 1rem;
            width: 320px;
            max-width: calc(100vw - 2rem);
            background: rgba(12, 12, 28, 0.88);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
            z-index: 5;
            backdrop-filter: blur(6px);
        }

        #asteroid-panel .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }

        #asteroid-panel .panel-title {
            font-weight: 600;
            font-size: 1.05rem;
            margin-bottom: 0.5rem;
            margin-top: 0.1rem;
        }

        #asteroid-panel .collapse-btn {
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: rgba(255, 255, 255, 0.04);
            color: #f5f5f5;
            border-radius: 6px;
            padding: 0.2rem 0.6rem;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.72rem;
            letter-spacing: 0.06em;
        }

        #asteroid-panel .collapse-btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        #asteroid-panel .panel-body {
            margin-top: 0.75rem;
        }

        #asteroid-panel.collapsed .panel-body {
            display: none;
        }

        #asteroid-panel label {
            display: block;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #c3c3d7;
        }

        #asteroid-panel .controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.35rem;
            flex-wrap: nowrap;
        }

        #asteroid-panel input[type="date"] {
            flex: 1;
            padding: 0.4rem 0.5rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(10, 10, 22, 0.8);
            color: #f5f5f5;
        }

        #asteroid-panel button[type="submit"] {
            padding: 0.45rem 0.85rem;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #3d82ff, #6a5bff);
            color: #fff;
        }

        #asteroid-panel button[type="submit"]:hover {
            background: linear-gradient(135deg, #5b9aff, #8970ff);
        }

        #asteroid-panel .date-nav {
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.04);
            color: #f5f5f5;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        #asteroid-panel .date-nav:hover {
            background: rgba(255, 255, 255, 0.14);
        }

        #asteroid-panel .scene-toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            color: #d1d1e0;
            margin-top: 0.6rem;
        }

        #asteroid-panel .scene-toggle input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            accent-color: #6a5bff;
        }

        #asteroid-status {
            font-size: 0.85rem;
            margin-top: 0.75rem;
        }

        #asteroid-list {
            list-style: none;
            padding: 0;
            margin: 0.75rem 0 0;
            max-height: 280px;
            overflow-y: auto;
        }

        #asteroid-list li {
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            padding-bottom: 0.6rem;
            margin-bottom: 0.6rem;
            border-left: 4px solid rgba(255, 255, 255, 0.12);
            padding-left: 0.6rem;
            transition: border-color 0.2s ease;
        }

        #asteroid-list li:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .asteroid-name {
            font-size: 0.95rem;
            font-weight: 600;
        }

        .asteroid-name a {
            color: #8ec6ff;
            text-decoration: none;
        }

        .asteroid-name a:hover {
            text-decoration: underline;
        }

        .asteroid-meta {
            font-size: 0.8rem;
            color: #d1d1e0;
            margin-top: 0.25rem;
        }

        #asteroid-list li.hazardous .asteroid-name {
            color: #ff7676;
        }
    </style>
</head>

<body>
    <div id="asteroid-panel" class="expanded">
        <div class="panel-header">
            <div class="panel-title">Near-Earth Asteroids</div>
            <button type="button" id="asteroid-collapse-btn" class="collapse-btn" aria-expanded="true" aria-controls="asteroid-panel-body">Hide</button>
        </div>
        <div id="asteroid-panel-body" class="panel-body">
            <form id="asteroid-form">
                <label for="asteroid-date">Select date</label>
                <div class="controls">
                    <button type="button" class="date-nav" data-offset="-1" aria-label="Previous day">Prev</button>
                    <input type="date" id="asteroid-date" name="asteroid-date" required>
                    <button type="button" class="date-nav" data-offset="1" aria-label="Next day">Next</button>
                    <button type="submit">Fetch</button>
                </div>
            </form>
            <label class="scene-toggle">
                <input type="checkbox" id="asteroid-scene-toggle">
                Show in scene
            </label>
            <div id="asteroid-status" role="status" aria-live="polite">Pick a date to load asteroid data.</div>
            <ul id="asteroid-list"></ul>
        </div>
    </div>
    <script src="config/api-base.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://82mou.github.io/threejs/js/OrbitControls.js"></script>
    <script>
        // Setup scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        // hexa code for purple is #800080
        // const pointLight = new THREE.PointLight(0x800080, 1, 0);
        // hexa code for yellow is #ffff00
        //const pointLight = new THREE.PointLight(0xffff00, 1, 0);
        const pointLight = new THREE.PointLight(0xffffff, 1, 0);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);

        const textureLoader = new THREE.TextureLoader();

        // Add the sun
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const texture = textureLoader.load('assets/sun.jpg');
        const sunMaterial = new THREE.MeshStandardMaterial({ map: texture }); // { color: 0xffff00 });
        const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sunMesh);

        // Planets populated dynamically from backend API
        const planets = [];
        // Rockets array must be declared before first animation frame calls updateRockets()
        const rockets = [];
        // Queue of incoming rocket launch directives from backend SSE
        const liveQueue = [];
        const asteroidUi = {
            panel: document.getElementById('asteroid-panel'),
            panelBody: document.getElementById('asteroid-panel-body'),
            collapseBtn: document.getElementById('asteroid-collapse-btn'),
            form: document.getElementById('asteroid-form'),
            date: document.getElementById('asteroid-date'),
            sceneToggle: document.getElementById('asteroid-scene-toggle'),
            status: document.getElementById('asteroid-status'),
            list: document.getElementById('asteroid-list'),
            navButtons: Array.from(document.querySelectorAll('#asteroid-panel .date-nav'))
        };
        let asteroidFetchController = null;
        const asteroidRenderState = {
            data: [],
            group: null
        };
        let showAsteroidsInScene = false;

        function initAsteroidUi() {
            if (!asteroidUi.date || !asteroidUi.form || !asteroidUi.status || !asteroidUi.list) {
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            asteroidUi.date.value = today;
            asteroidUi.date.max = today;
            syncDateNavState();

            if (asteroidUi.collapseBtn && asteroidUi.panel) {
                asteroidUi.collapseBtn.addEventListener('click', () => {
                    const willCollapse = !asteroidUi.panel.classList.contains('collapsed');
                    setPanelCollapsed(willCollapse);
                });
                setPanelCollapsed(false);
            }

            if (asteroidUi.sceneToggle) {
                asteroidUi.sceneToggle.checked = showAsteroidsInScene;
                asteroidUi.sceneToggle.addEventListener('change', () => {
                    showAsteroidsInScene = asteroidUi.sceneToggle.checked;
                    updateAsteroidMeshes();
                });
            }

            if (Array.isArray(asteroidUi.navButtons)) {
                asteroidUi.navButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const offset = Number.parseInt(btn.dataset.offset ?? '0', 10);
                        if (!Number.isFinite(offset) || offset === 0) {
                            return;
                        }
                        adjustAsteroidDateBy(offset);
                    });
                });
            }

            asteroidUi.form.addEventListener('submit', event => {
                event.preventDefault();
                if (asteroidUi.date.value) {
                    syncDateNavState();
                    fetchAsteroids(asteroidUi.date.value);
                }
            });

            asteroidUi.date.addEventListener('change', () => {
                if (asteroidUi.date.value) {
                    syncDateNavState();
                    fetchAsteroids(asteroidUi.date.value);
                }
            });

            fetchAsteroids(today);
        }

        function setPanelCollapsed(collapsed) {
            if (!asteroidUi.panel || !asteroidUi.collapseBtn) {
                return;
            }
            asteroidUi.panel.classList.toggle('collapsed', collapsed);
            asteroidUi.panel.classList.toggle('expanded', !collapsed);
            asteroidUi.collapseBtn.setAttribute('aria-expanded', String(!collapsed));
            asteroidUi.collapseBtn.textContent = collapsed ? 'Show' : 'Hide';
        }

        function adjustAsteroidDateBy(offsetDays) {
            if (!asteroidUi.date) {
                return;
            }

            const currentValue = asteroidUi.date.value;
            const todayStr = new Date().toISOString().split('T')[0];
            const todayDate = new Date(`${todayStr}T00:00:00Z`);
            let target = currentValue ? new Date(`${currentValue}T00:00:00Z`) : new Date(`${todayStr}T00:00:00Z`);

            if (Number.isNaN(target.getTime())) {
                target = new Date(`${todayStr}T00:00:00Z`);
            }

            target.setUTCDate(target.getUTCDate() + offsetDays);

            if (target > todayDate) {
                target = todayDate;
            }

            asteroidUi.date.value = formatAsInputDate(target);
            syncDateNavState();
            fetchAsteroids(asteroidUi.date.value);
        }

        function syncDateNavState() {
            if (!Array.isArray(asteroidUi.navButtons) || !asteroidUi.date) {
                return;
            }

            const todayStr = new Date().toISOString().split('T')[0];
            const currentValue = asteroidUi.date.value;

            asteroidUi.navButtons.forEach(btn => {
                const offset = Number.parseInt(btn.dataset.offset ?? '0', 10);
                if (!Number.isFinite(offset) || offset <= 0) {
                    btn.disabled = false;
                    return;
                }
                btn.disabled = typeof currentValue === 'string' && currentValue >= todayStr;
            });
        }

        async function fetchAsteroids(date) {
            if (!date || !asteroidUi.status || !asteroidUi.list) {
                return;
            }

            syncDateNavState();

            asteroidFetchController?.abort();
            const controller = new AbortController();
            asteroidFetchController = controller;

            asteroidUi.status.textContent = 'Loading asteroids...';
            asteroidUi.list.innerHTML = '';
            asteroidRenderState.data = [];
            updateAsteroidMeshes();

            try {
                const base = resolveApiBase();
                const response = await fetch(`${base}/api/planets/asteroids?date=${encodeURIComponent(date)}`, { signal: controller.signal });

                if (asteroidFetchController !== controller || controller.signal.aborted) {
                    return;
                }

                if (!response.ok) {
                    asteroidUi.status.textContent = `Asteroid request failed (${response.status}).`;
                    asteroidRenderState.data = [];
                    updateAsteroidMeshes();
                    return;
                }

                const result = await response.json();

                if (asteroidFetchController !== controller || controller.signal.aborted) {
                    return;
                }

                renderAsteroids(result);
            } catch (error) {
                if (asteroidFetchController !== controller || controller.signal.aborted) {
                    return;
                }

                console.error('Asteroid API request failed', error);
                asteroidUi.status.textContent = 'Unable to load asteroid data.';
                asteroidRenderState.data = [];
                updateAsteroidMeshes();
            }
        }

        function renderAsteroids(result) {
            if (!asteroidUi.status || !asteroidUi.list) {
                return;
            }

            asteroidUi.list.innerHTML = '';

            const asteroids = Array.isArray(result?.asteroids)
                ? result.asteroids.map(item => ({
                    ...item,
                    _color: generateAsteroidColor(item?.isPotentiallyHazardous)
                }))
                : [];
            const displayDate = typeof result?.date === 'string' && result.date
                ? result.date
                : asteroidUi.date?.value || '';

            if (asteroids.length === 0) {
                asteroidRenderState.data = [];
                updateAsteroidMeshes();
                asteroidUi.status.textContent = displayDate
                    ? `No asteroids reported near Earth on ${displayDate}.`
                    : 'No asteroid data available.';
                return;
            }

            asteroids.sort((a, b) => {
                const aDistance = typeof a?.closestApproachDistanceKm === 'number' ? a.closestApproachDistanceKm : Number.POSITIVE_INFINITY;
                const bDistance = typeof b?.closestApproachDistanceKm === 'number' ? b.closestApproachDistanceKm : Number.POSITIVE_INFINITY;
                return aDistance - bDistance;
            });

            asteroidRenderState.data = asteroids;
            updateAsteroidMeshes();

            asteroidUi.status.textContent = displayDate
                ? `Found ${asteroids.length} near-Earth objects on ${displayDate}.`
                : `Found ${asteroids.length} near-Earth objects.`;

            const fragment = document.createDocumentFragment();

            asteroids.forEach(item => {
                const li = document.createElement('li');
                if (item?.isPotentiallyHazardous) {
                    li.classList.add('hazardous');
                }

                const colorHex = typeof item?._color === 'number'
                    ? item._color
                    : generateAsteroidColor(item?.isPotentiallyHazardous);
                li.style.borderLeftColor = colorToCss(colorHex);

                const name = typeof item?.name === 'string' && item.name.trim().length > 0
                    ? item.name.trim()
                    : (typeof item?.id === 'string' && item.id.trim().length > 0 ? item.id.trim() : 'Unknown object');

                const title = document.createElement('div');
                title.className = 'asteroid-name';

                if (typeof item?.referenceUrl === 'string' && item.referenceUrl.startsWith('http')) {
                    const link = document.createElement('a');
                    link.href = item.referenceUrl;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.textContent = name;
                    title.appendChild(link);
                } else {
                    title.textContent = name;
                }

                li.appendChild(title);

                const meta = document.createElement('div');
                meta.className = 'asteroid-meta';
                const size = formatKm(item?.estimatedMaxDiameterKm, 2);
                const distance = formatKm(item?.closestApproachDistanceKm, 0);
                const hazardLabel = item?.isPotentiallyHazardous ? 'Potentially hazardous' : 'Not hazardous';
                meta.textContent = `Size ~ ${size} km | Miss distance ~ ${distance} km | ${hazardLabel}`;
                li.appendChild(meta);

                fragment.appendChild(li);
            });

            asteroidUi.list.appendChild(fragment);
        }

        function formatKm(value, maxFractionDigits) {
            if (typeof value !== 'number' || Number.isNaN(value) || !Number.isFinite(value)) {
                return 'N/A';
            }

            return value.toLocaleString(undefined, {
                minimumFractionDigits: 0,
                maximumFractionDigits: Math.max(0, maxFractionDigits)
            });
        }

        function formatAsInputDate(date) {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
                return new Date().toISOString().split('T')[0];
            }

            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function generateAsteroidColor(isHazardous) {
            const hue = Math.random();
            const saturation = isHazardous ? 0.85 : 0.6;
            const lightness = isHazardous ? 0.5 : 0.64;
            const color = new THREE.Color();
            color.setHSL(hue, saturation, lightness);
            return color.getHex();
        }

        function deriveAsteroidEmissive(colorHex, isHazardous) {
            const base = new THREE.Color(colorHex);
            const hsl = { h: 0, s: 0, l: 0 };
            base.getHSL(hsl);
            const adjusted = new THREE.Color();
            const saturation = THREE.MathUtils.clamp(hsl.s + (isHazardous ? 0.1 : -0.2), 0, 1);
            const lightness = THREE.MathUtils.clamp(hsl.l + (isHazardous ? -0.15 : -0.3), 0, 1);
            adjusted.setHSL(hsl.h, saturation, lightness);
            return adjusted.getHex();
        }

        function colorToCss(hex) {
            const value = typeof hex === 'number' && Number.isInteger(hex) ? hex : 0xffffff;
            return `#${value.toString(16).padStart(6, '0')}`;
        }

        function updateAsteroidMeshes() {
            clearAsteroidMeshes();
            if (!showAsteroidsInScene) {
                return;
            }

            if (!Array.isArray(asteroidRenderState.data) || asteroidRenderState.data.length === 0) {
                return;
            }

            const earth = getEarthPlanet();
            if (!earth?.mesh) {
                return;
            }

            const group = new THREE.Group();
            group.name = 'asteroid-markers';

            // Distribute markers around Earth with a radial spread scaled by their miss distance so viewers get an at-a-glance comparison.

            const maxDistance = asteroidRenderState.data.reduce((max, item) => {
                const distance = typeof item?.closestApproachDistanceKm === 'number' ? item.closestApproachDistanceKm : 0;
                return distance > max ? distance : max;
            }, 0);
            const safeMaxDistance = maxDistance > 0 ? maxDistance : 1;

            asteroidRenderState.data.forEach((item, index) => {
                const distanceKm = typeof item?.closestApproachDistanceKm === 'number' ? item.closestApproachDistanceKm : safeMaxDistance;
                const diameterKm = typeof item?.estimatedMaxDiameterKm === 'number' ? item.estimatedMaxDiameterKm : 0;
                const normalized = Math.min(distanceKm / safeMaxDistance, 1);
                const radialDistance = earth.size * (2 + normalized * 18);
                const angle = (index / asteroidRenderState.data.length) * Math.PI * 2;
                const elevation = (normalized - 0.5) * earth.size * 8;

                const radiusScale = diameterKm > 0 ? THREE.MathUtils.clamp(diameterKm / 1000, 0.15, 1) : 0.2;
                const markerGeo = new THREE.SphereGeometry(radiusScale, 12, 12);
                const colorHex = typeof item?._color === 'number'
                    ? item._color
                    : generateAsteroidColor(item?.isPotentiallyHazardous);
                item._color = colorHex;
                const emissiveHex = deriveAsteroidEmissive(colorHex, item?.isPotentiallyHazardous);
                const markerMat = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    emissive: emissiveHex,
                    emissiveIntensity: item?.isPotentiallyHazardous ? 0.65 : 0.35,
                    roughness: 0.4,
                    metalness: 0.2
                });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.position.set(
                    Math.cos(angle) * radialDistance,
                    elevation,
                    Math.sin(angle) * radialDistance
                );
                marker.userData = {
                    asteroidId: item?.id ?? null,
                    asteroidName: item?.name ?? null
                };

                group.add(marker);
            });

            earth.mesh.add(group);
            asteroidRenderState.group = group;
        }

        function clearAsteroidMeshes() {
            if (!asteroidRenderState.group) {
                return;
            }

            const group = asteroidRenderState.group;
            asteroidRenderState.group = null;
            if (group.parent) {
                group.parent.remove(group);
            }
            disposeObject(group);
        }

        function getEarthPlanet() {
            return planets.find(p => typeof p?.name === 'string' && p.name.toLowerCase() === 'earth');
        }

        function resolveApiBase() {
            // Prefer injected value; fallback to current origin
            if (typeof window.API_BASE_URL === 'string' && window.API_BASE_URL.trim().length > 0) {
                return window.API_BASE_URL.replace(/\/$/, '');
            }
            return window.location.origin;
        }

        async function loadPlanets() {
            const base = resolveApiBase();
            const apiUrl = `${base}/api/planets`;
            let data = null;
            try {
                const res = await fetch(apiUrl);
                if (res.ok) {
                    data = await res.json();
                }
            } catch { /* ignore; will fallback */ }
            if (!data) {
                console.warn('Falling back to static dataset - API unreachable.');
                data = [
                    // { name: 'Mercury', size: 0.383, distance: 5.79, speed: 0.08, rotationSpeed: 0.01, textureUrl: 'assets/mercury.jpg' },
                    // { name: 'Venus', size: 0.949, distance: 10.82, speed: 0.03, rotationSpeed: 0.006, textureUrl: 'assets/venus.jpg' },
                    // { name: 'Earth', size: 1, distance: 15, speed: 0.02, rotationSpeed: 0.008, textureUrl: 'assets/earth.jpg' },
                    // { name: 'Mars', size: 0.532, distance: 22.79, speed: 0.016, rotationSpeed: 0.012, textureUrl: 'assets/mars.jpg' },
                    // { name: 'Jupiter', size: 11.21, distance: 77.78, speed: 0.004, rotationSpeed: 0.014, textureUrl: 'assets/jupiter.jpg' },
                    // { name: 'Saturn', size: 9.45, distance: 143.37, speed: 0.002, rotationSpeed: 0.016, textureUrl: 'assets/saturn.jpg' },
                    // { name: 'Uranus', size: 4.01, distance: 287.1, speed: 0.0008, rotationSpeed: 0.018, textureUrl: 'assets/uranus.jpg' },
                    // { name: 'Neptune', size: 3.88, distance: 449.5, speed: 0.0004, rotationSpeed: 0.02, textureUrl: 'assets/neptune.jpg' }
                ];
            }
            data.forEach(p => planets.push({
                name: p.name,
                size: p.size,
                distance: p.distance,
                speed: p.speed,
                rotationSpeed: p.rotationSpeed,
                texture: p.textureUrl
            }));
            createPlanetMeshes();
        }

        function createPlanetMeshes() {
            planets.forEach(planet => {
                const texture = textureLoader.load(planet.texture);
                const geometry = new THREE.SphereGeometry(planet.size, 32, 32);
                const material = new THREE.MeshStandardMaterial({ map: texture });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                planet.mesh = mesh;
                const orbitGeometry = new THREE.RingGeometry(planet.distance - 0.1, planet.distance + 0.1, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                scene.add(orbit);

                // Add planetary ring systems (Saturn & Uranus) if textures available
                if (planet.name === 'Saturn') {
                    addRingSystem(planet, {
                        texture: 'assets/saturn-rings.jpg',
                        innerScale: 1.25, // relative to planet radius
                        outerScale: 2.3,
                        tiltDegX: 27, // approximate axial tilt for a bit of realism
                        opacity: 0.9
                    });
                } else if (planet.name === 'Uranus') {
                    addRingSystem(planet, {
                        texture: 'assets/uranus-rings.jpg',
                        innerScale: 1.15,
                        outerScale: 1.9,
                        tiltDegX: 98, // Uranus essentially on its side
                        opacity: 0.85
                    });
                }
            });

            // Once planets are created, start launching rockets
            initRocketSystem();
            initRocketSse(); // connect to backend for directed launches
            updateAsteroidMeshes();
        }

        // Helper to add a textured ring to a planet. Rings are attached as child meshes so they follow the planet's orbit & rotation.
        function addRingSystem(planet, options) {
            const { texture, innerScale, outerScale, tiltDegX, opacity } = options;
            const ringTex = textureLoader.load(texture);
            // Even though JPG lacks alpha, keep transparent flag in case assets are swapped for PNG later.
            ringTex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
            const inner = planet.size * innerScale;
            const outer = planet.size * outerScale;
            const ringGeo = new THREE.RingGeometry(inner, outer, 128, 1);
            // Create a faded look using vertex colors (alpha falloff) if possible
            // Inject simple alpha gradient via custom material with onBeforeCompile (lightweight tweak)
            const ringMat = new THREE.MeshBasicMaterial({ map: ringTex, side: THREE.DoubleSide, transparent: true, opacity });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            // Default RingGeometry is in XY plane; rotate so it lies in planet's orbital plane (XZ), then apply tilt.
            ring.rotation.x = Math.PI / 2; // align with orbital plane
            if (typeof tiltDegX === 'number') {
                // Apply additional axial tilt around Z axis for a more natural look
                ring.rotation.z = THREE.MathUtils.degToRad(tiltDegX);
            }
            ring.renderOrder = 1; // draw after planet for fewer z-fighting artifacts
            planet.mesh.add(ring); // center on planet
            planet.ring = ring;
        }

    initAsteroidUi();
    loadPlanets();

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.z = 200;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.0002; // Increase the speed of the orbits
            planets.forEach(planet => {
                planet.mesh.rotation.y += planet.rotationSpeed; // Rotate each planet with different speeds
                const angle = time * planet.speed;
                planet.mesh.position.x = planet.distance * Math.cos(angle);
                planet.mesh.position.z = planet.distance * Math.sin(angle);
            });

            // Update rockets
            updateRockets();
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    // ---------------- Rocket Launch Feature ----------------
        const rocketConfig = {
            minInterval: 5000, // ms
            maxInterval: 12000, // ms
            flightDuration: 8000, // ms per flight
            trailSpawnInterval: 90, // ms between trail particle spawns
            trailLifetime: 1800, // ms a particle lives
            maxTrailParticles: 120
        };

        function initRocketSystem() {
            // Ensure Earth exists before scheduling
            if (!planets.find(p => p.name.toLowerCase() === 'earth')) return;
            scheduleNextLaunch();
        }

        function scheduleNextLaunch() {
            const interval = THREE.MathUtils.randInt(rocketConfig.minInterval, rocketConfig.maxInterval);
            setTimeout(() => {
                if (liveQueue.length > 0) {
                    const msg = liveQueue.shift();
                    if (msg?.destination) launchDirectedRocket(msg.destination);
                    // else launchRandomRocket();
                } else {
                    // launchRandomRocket();
                }
                scheduleNextLaunch();
            }, interval);
        }

        function initRocketSse() {
            const base = resolveApiBase();
            const url = `${base}/api/rockets/stream`;
            try {
                const es = new EventSource(url);
                es.onmessage = e => {
                    try {
                        const data = JSON.parse(e.data);
                        if (data?.destination) liveQueue.push(data);
                    } catch { }
                };
                es.onerror = () => { es.close(); console.warn('Rocket SSE stream error; closing.'); };
                console.log('Connected to rocket SSE', url);
            } catch {
                console.warn('Rocket SSE stream unavailable â€“ using random launches only.');
            }
        }

        function launchRandomRocket() {
            const earth = planets.find(p => p.name.toLowerCase() === 'earth');
            const candidates = planets.filter(p => p !== earth);
            if (!earth || candidates.length === 0) return;
            const target = candidates[Math.floor(Math.random() * candidates.length)];
            launchBetween(earth, target);
        }

        function launchDirectedRocket(destinationName) {
            const earth = planets.find(p => p.name.toLowerCase() === 'earth');
            const target = planets.find(p => p.name.toLowerCase() === destinationName.toLowerCase());
            if (!earth || !target || earth === target) return;
            launchBetween(earth, target);
        }

        function launchBetween(earth, target) {
            const start = earth.mesh.position.clone();
            const end = target.mesh.position.clone();
            const mid = start.clone().add(end).multiplyScalar(0.5);
            mid.y += start.distanceTo(end) * 0.25 + 5;
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(50);
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.7 });
            const trajectoryLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(trajectoryLine);
            const rocket = createRocketMesh();
            rocket.position.copy(start.clone().setY(start.y + earth.size * 0.2 + 0.5));
            scene.add(rocket);
            rockets.push({
                mesh: rocket,
                line: trajectoryLine,
                curve,
                startTime: performance.now(),
                duration: rocketConfig.flightDuration,
                disposed: false,
                lastTrailTime: 0,
                trail: []
            });
        }

        function createRocketMesh() {
            const group = new THREE.Group();
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.25, 1.2, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);
            const noseGeo = new THREE.ConeGeometry(0.25, 0.5, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.3, roughness: 0.4 });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 0.85; // top of body
            group.add(nose);
            const finGeo = new THREE.BoxGeometry(0.05, 0.3, 0.4);
            const finMat = new THREE.MeshStandardMaterial({ color: 0x3333ff });
            for (let i = 0; i < 3; i++) {
                const fin = new THREE.Mesh(finGeo, finMat);
                fin.position.y = -0.5;
                fin.rotation.y = (i / 3) * Math.PI * 2;
                fin.position.x = Math.sin(fin.rotation.y) * 0.25;
                fin.position.z = Math.cos(fin.rotation.y) * 0.25;
                group.add(fin);
            }
            return group;
        }

        function updateRockets() {
            if (rockets.length === 0) return;
            const now = performance.now();
            for (let i = rockets.length - 1; i >= 0; i--) {
                const r = rockets[i];
                const t = (now - r.startTime) / r.duration;
                if (t >= 1) {
                    // fade out & cleanup
                    if (!r.disposed) {
                        scene.remove(r.mesh);
                        scene.remove(r.line);
                        disposeObject(r.mesh);
                        disposeObject(r.line);
                        r.disposed = true;
                    }
                    rockets.splice(i, 1);
                    continue;
                }
                const eased = easeInOutCubic(t);
                const pos = r.curve.getPoint(eased);
                r.mesh.position.copy(pos);
                // Orient rocket along tangent
                const tangent = r.curve.getTangent(eased).normalize();
                const axis = new THREE.Vector3(0, 1, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(axis, tangent.clone().normalize());
                r.mesh.setRotationFromQuaternion(quat);
                // Add gentle roll
                r.mesh.rotateY(now * 0.002);

                // Trail spawning
                if (now - r.lastTrailTime > rocketConfig.trailSpawnInterval) {
                    spawnTrailParticle(r);
                    r.lastTrailTime = now;
                }
                updateTrail(r, now);
            }
        }

        function spawnTrailParticle(rocket) {
            if (rocket.trail.length >= rocketConfig.maxTrailParticles) {
                // Recycle oldest
                const oldest = rocket.trail.shift();
                scene.remove(oldest.mesh);
                disposeObject(oldest.mesh);
            }
            const geo = new THREE.SphereGeometry(0.12, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffddaa, transparent: true, opacity: 0.9 });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.copy(rocket.mesh.position);
            scene.add(particle);
            rocket.trail.push({ mesh: particle, born: performance.now() });
        }

        function updateTrail(rocket, now) {
            for (let i = rocket.trail.length - 1; i >= 0; i--) {
                const p = rocket.trail[i];
                const age = now - p.born;
                const t = age / rocketConfig.trailLifetime;
                if (t >= 1) {
                    scene.remove(p.mesh);
                    disposeObject(p.mesh);
                    rocket.trail.splice(i, 1);
                    continue;
                }
                const fade = 1 - t; // linear fade; could ease
                p.mesh.material.opacity = fade;
                const scale = 1 - t * 0.7; // slight shrink
                p.mesh.scale.setScalar(scale);
            }
        }

        function disposeObject(obj) {
            obj.traverse?.(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            });
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }
        // --------------------------------------------------------
    </script>
</body>

</html>